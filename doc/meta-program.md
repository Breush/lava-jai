 # Meta-program usage

In `modules/Sill/meta.jai`, you will find a function named `sill_meta_handle_message` that can
be called while compiling your program using the `Sill` module.

It should look like:
```jai
Compiler.compiler_begin_intercept(workspace);
Compiler.add_build_file("main.jai", workspace);

while true {
    message := Compiler.compiler_wait_for_message();
    if !message break;
    if message.workspace != workspace continue;

    sill_meta_handle_message(message);

    if message.kind == .COMPLETE {
        break;
    }
}

Compiler.compiler_end_intercept(workspace);
```

Once this is done, in your main program, create your engine like this:
```jai
engine := Sill.create_engine(SillMeta); // SillMeta has been generated by the meta-program.
```

This will allow you to use the meta-program features explained below.

# Meta-program features

## Automatic entities storage

Your entities will be automatically detected as-long-as you inherit from `Sill.Entity`.

```jai
TreeEntity :: struct {
    using #as entity : Sill.Entity;
    transform : Sill.TransformComponent;
    mesh : Sill.MeshComponent;
}
```

The main point of having a meta-program at all is to be efficient memory-wise.
Here's what the meta-program will generate with some comments added:

```jai
SillMeta :: struct {
    // This is the type of the storage for all entities.
    // All similar entities will be stored together in compact arrays.
    Entities :: struct {
        tree : [..]TreeEntity;
    }

    // Helper to be called like engine.Meta.create_tree_entity(engine);
    // One helper per entity type will be created.
    create_tree_entity :: (engine : *Sill.Engine) -> *TreeEntity {
        array := *engine.entities.tree;
        Basic.array_resize(array, array.count + 1);
        entity := Basic.peek_pointer(engine.entities.tree);
        engine.Meta.entity_init(entity, engine);
        return entity;
    }

    // Call by create_tree_entity, but can be called freely if needed.
    // It inits the entity's components (with there dependencies).
    entity_init :: (entity : *TreeEntity, engine : *Sill.EngineBase) {
        entity.engine = engine;
        entity.transform.entity = entity;
        Sill.component_init(*entity.transform);
        entity.mesh.entity = entity;
        entity.mesh.transform = *entity.transform;
        Sill.component_init(*entity.mesh);
    }

    entity_cleanup :: (entity : *TreeEntity) {
        Sill.component_cleanup(*entity.transform);
        Sill.component_cleanup(*entity.mesh);
    }

    entity_update :: (entity : *TreeEntity, dt : float64) {
        Sill.component_update(*entity.transform, dt);
        Sill.component_update(*entity.mesh, dt);
    }

    _cleanup_entities :: (engine : *Sill.Engine) {
        for *entity : engine.entities.tree {
            engine.Meta.entity_cleanup(entity);
        }
        Basic.array_free(engine.entities.tree);
    }

    _update_entities :: (engine : *Sill.Engine, dt : float64) {
        for *entity : engine.entities.tree {
            engine.Meta.entity_update(entity, dt);
        }
    }

}
```
